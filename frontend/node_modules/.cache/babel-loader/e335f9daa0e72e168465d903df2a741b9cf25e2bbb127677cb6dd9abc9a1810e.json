{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doesTextFitInRect = doesTextFitInRect;\nexports.ellipsize = ellipsize;\nvar _getGraphemeCount = require(\"./getGraphemeCount\");\nvar _degToRad = require(\"./degToRad\");\nvar _sliceUntil = require(\"./sliceUntil\");\nconst ELLIPSIS = '…';\nfunction doesTextFitInRect(text, config) {\n  const {\n    width,\n    height,\n    measureText\n  } = config;\n  const angle = (0, _degToRad.degToRad)(config.angle);\n  const textSize = measureText(text);\n  const angledWidth = Math.abs(textSize.width * Math.cos(angle)) + Math.abs(textSize.height * Math.sin(angle));\n  const angledHeight = Math.abs(textSize.width * Math.sin(angle)) + Math.abs(textSize.height * Math.cos(angle));\n  return angledWidth <= width && angledHeight <= height;\n}\n\n/** This function finds the best place to clip the text to add an ellipsis.\n *  This function assumes that the {@link doesTextFit} never returns true for longer text after returning false for\n *  shorter text.\n *\n *  @param text Text to ellipsize if needed\n *  @param doesTextFit a function that returns whether a string fits inside a container.\n */\nfunction ellipsize(text, doesTextFit) {\n  if (doesTextFit(text)) {\n    return text;\n  }\n  let shortenedText = text;\n  let step = 1;\n  let by = 1 / 2;\n  const graphemeCount = (0, _getGraphemeCount.getGraphemeCount)(text);\n  let newLength = graphemeCount;\n  let lastLength = graphemeCount;\n  let longestFittingText = null;\n  do {\n    lastLength = newLength;\n    newLength = Math.floor(graphemeCount * by);\n    if (newLength === 0) {\n      break;\n    }\n    shortenedText = (0, _sliceUntil.sliceUntil)(text, newLength).trim();\n    const fits = doesTextFit(shortenedText + ELLIPSIS);\n    step += 1;\n    if (fits) {\n      longestFittingText = shortenedText;\n      by += 1 / 2 ** step;\n    } else {\n      by -= 1 / 2 ** step;\n    }\n  } while (Math.abs(newLength - lastLength) !== 1);\n  return longestFittingText ? longestFittingText + ELLIPSIS : '';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","doesTextFitInRect","ellipsize","_getGraphemeCount","require","_degToRad","_sliceUntil","ELLIPSIS","text","config","width","height","measureText","angle","degToRad","textSize","angledWidth","Math","abs","cos","sin","angledHeight","doesTextFit","shortenedText","step","by","graphemeCount","getGraphemeCount","newLength","lastLength","longestFittingText","floor","sliceUntil","trim","fits"],"sources":["C:/Users/LIJIN/Desktop/webTest/Bak/webTest/frontend/node_modules/@mui/x-charts/internals/ellipsize.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doesTextFitInRect = doesTextFitInRect;\nexports.ellipsize = ellipsize;\nvar _getGraphemeCount = require(\"./getGraphemeCount\");\nvar _degToRad = require(\"./degToRad\");\nvar _sliceUntil = require(\"./sliceUntil\");\nconst ELLIPSIS = '…';\nfunction doesTextFitInRect(text, config) {\n  const {\n    width,\n    height,\n    measureText\n  } = config;\n  const angle = (0, _degToRad.degToRad)(config.angle);\n  const textSize = measureText(text);\n  const angledWidth = Math.abs(textSize.width * Math.cos(angle)) + Math.abs(textSize.height * Math.sin(angle));\n  const angledHeight = Math.abs(textSize.width * Math.sin(angle)) + Math.abs(textSize.height * Math.cos(angle));\n  return angledWidth <= width && angledHeight <= height;\n}\n\n/** This function finds the best place to clip the text to add an ellipsis.\n *  This function assumes that the {@link doesTextFit} never returns true for longer text after returning false for\n *  shorter text.\n *\n *  @param text Text to ellipsize if needed\n *  @param doesTextFit a function that returns whether a string fits inside a container.\n */\nfunction ellipsize(text, doesTextFit) {\n  if (doesTextFit(text)) {\n    return text;\n  }\n  let shortenedText = text;\n  let step = 1;\n  let by = 1 / 2;\n  const graphemeCount = (0, _getGraphemeCount.getGraphemeCount)(text);\n  let newLength = graphemeCount;\n  let lastLength = graphemeCount;\n  let longestFittingText = null;\n  do {\n    lastLength = newLength;\n    newLength = Math.floor(graphemeCount * by);\n    if (newLength === 0) {\n      break;\n    }\n    shortenedText = (0, _sliceUntil.sliceUntil)(text, newLength).trim();\n    const fits = doesTextFit(shortenedText + ELLIPSIS);\n    step += 1;\n    if (fits) {\n      longestFittingText = shortenedText;\n      by += 1 / 2 ** step;\n    } else {\n      by -= 1 / 2 ** step;\n    }\n  } while (Math.abs(newLength - lastLength) !== 1);\n  return longestFittingText ? longestFittingText + ELLIPSIS : '';\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB;AAC7CF,OAAO,CAACG,SAAS,GAAGA,SAAS;AAC7B,IAAIC,iBAAiB,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AACrD,IAAIC,SAAS,GAAGD,OAAO,CAAC,YAAY,CAAC;AACrC,IAAIE,WAAW,GAAGF,OAAO,CAAC,cAAc,CAAC;AACzC,MAAMG,QAAQ,GAAG,GAAG;AACpB,SAASN,iBAAiBA,CAACO,IAAI,EAAEC,MAAM,EAAE;EACvC,MAAM;IACJC,KAAK;IACLC,MAAM;IACNC;EACF,CAAC,GAAGH,MAAM;EACV,MAAMI,KAAK,GAAG,CAAC,CAAC,EAAER,SAAS,CAACS,QAAQ,EAAEL,MAAM,CAACI,KAAK,CAAC;EACnD,MAAME,QAAQ,GAAGH,WAAW,CAACJ,IAAI,CAAC;EAClC,MAAMQ,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACL,KAAK,GAAGO,IAAI,CAACE,GAAG,CAACN,KAAK,CAAC,CAAC,GAAGI,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACJ,MAAM,GAAGM,IAAI,CAACG,GAAG,CAACP,KAAK,CAAC,CAAC;EAC5G,MAAMQ,YAAY,GAAGJ,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACL,KAAK,GAAGO,IAAI,CAACG,GAAG,CAACP,KAAK,CAAC,CAAC,GAAGI,IAAI,CAACC,GAAG,CAACH,QAAQ,CAACJ,MAAM,GAAGM,IAAI,CAACE,GAAG,CAACN,KAAK,CAAC,CAAC;EAC7G,OAAOG,WAAW,IAAIN,KAAK,IAAIW,YAAY,IAAIV,MAAM;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAST,SAASA,CAACM,IAAI,EAAEc,WAAW,EAAE;EACpC,IAAIA,WAAW,CAACd,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI;EACb;EACA,IAAIe,aAAa,GAAGf,IAAI;EACxB,IAAIgB,IAAI,GAAG,CAAC;EACZ,IAAIC,EAAE,GAAG,CAAC,GAAG,CAAC;EACd,MAAMC,aAAa,GAAG,CAAC,CAAC,EAAEvB,iBAAiB,CAACwB,gBAAgB,EAAEnB,IAAI,CAAC;EACnE,IAAIoB,SAAS,GAAGF,aAAa;EAC7B,IAAIG,UAAU,GAAGH,aAAa;EAC9B,IAAII,kBAAkB,GAAG,IAAI;EAC7B,GAAG;IACDD,UAAU,GAAGD,SAAS;IACtBA,SAAS,GAAGX,IAAI,CAACc,KAAK,CAACL,aAAa,GAAGD,EAAE,CAAC;IAC1C,IAAIG,SAAS,KAAK,CAAC,EAAE;MACnB;IACF;IACAL,aAAa,GAAG,CAAC,CAAC,EAAEjB,WAAW,CAAC0B,UAAU,EAAExB,IAAI,EAAEoB,SAAS,CAAC,CAACK,IAAI,CAAC,CAAC;IACnE,MAAMC,IAAI,GAAGZ,WAAW,CAACC,aAAa,GAAGhB,QAAQ,CAAC;IAClDiB,IAAI,IAAI,CAAC;IACT,IAAIU,IAAI,EAAE;MACRJ,kBAAkB,GAAGP,aAAa;MAClCE,EAAE,IAAI,CAAC,GAAG,CAAC,IAAID,IAAI;IACrB,CAAC,MAAM;MACLC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAID,IAAI;IACrB;EACF,CAAC,QAAQP,IAAI,CAACC,GAAG,CAACU,SAAS,GAAGC,UAAU,CAAC,KAAK,CAAC;EAC/C,OAAOC,kBAAkB,GAAGA,kBAAkB,GAAGvB,QAAQ,GAAG,EAAE;AAChE","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}