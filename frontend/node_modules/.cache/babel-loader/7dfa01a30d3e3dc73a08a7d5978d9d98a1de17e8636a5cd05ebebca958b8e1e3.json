{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preprocessSeries = void 0;\n/**\n * This methods is the interface between what the developer is providing and what components receives\n * To simplify the components behaviors, it groups series by type, such that LinePlots props are not updated if some line data are modified\n * It also add defaultized values such as the ids, colors\n * @param series The array of series provided by the developer\n * @param colors The color palette used to defaultize series colors\n * @returns An object structuring all the series by type.\n */\nconst preprocessSeries = ({\n  series,\n  colors,\n  seriesConfig,\n  dataset\n}) => {\n  // Group series by type\n  const seriesGroups = {};\n  // Notice the line about uses `ChartSeriesType` instead of TSeriesType.\n  // That's probably because the series.type is not propagated from the generic but hardcoded in the config.\n\n  series.forEach((seriesData, seriesIndex) => {\n    const seriesWithDefaultValues = seriesConfig[seriesData.type].getSeriesWithDefaultValues(seriesData, seriesIndex, colors);\n    const id = seriesWithDefaultValues.id;\n    if (seriesGroups[seriesData.type] === undefined) {\n      seriesGroups[seriesData.type] = {\n        series: {},\n        seriesOrder: []\n      };\n    }\n    if (seriesGroups[seriesData.type]?.series[id] !== undefined) {\n      throw new Error(`MUI X Charts: series' id \"${id}\" is not unique.`);\n    }\n    seriesGroups[seriesData.type].series[id] = seriesWithDefaultValues;\n    seriesGroups[seriesData.type].seriesOrder.push(id);\n  });\n  const processedSeries = {};\n  // Apply formatter on a type group\n  Object.keys(seriesConfig).forEach(type => {\n    const group = seriesGroups[type];\n    if (group !== undefined) {\n      processedSeries[type] = seriesConfig[type]?.seriesProcessor?.(group, dataset) ?? seriesGroups[type];\n    }\n  });\n  return processedSeries;\n};\nexports.preprocessSeries = preprocessSeries;","map":{"version":3,"names":["Object","defineProperty","exports","value","preprocessSeries","series","colors","seriesConfig","dataset","seriesGroups","forEach","seriesData","seriesIndex","seriesWithDefaultValues","type","getSeriesWithDefaultValues","id","undefined","seriesOrder","Error","push","processedSeries","keys","group","seriesProcessor"],"sources":["C:/Users/LIJIN/Desktop/webTest/Bak/webTest/frontend/node_modules/@mui/x-charts/internals/plugins/corePlugins/useChartSeries/processSeries.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preprocessSeries = void 0;\n/**\n * This methods is the interface between what the developer is providing and what components receives\n * To simplify the components behaviors, it groups series by type, such that LinePlots props are not updated if some line data are modified\n * It also add defaultized values such as the ids, colors\n * @param series The array of series provided by the developer\n * @param colors The color palette used to defaultize series colors\n * @returns An object structuring all the series by type.\n */\nconst preprocessSeries = ({\n  series,\n  colors,\n  seriesConfig,\n  dataset\n}) => {\n  // Group series by type\n  const seriesGroups = {};\n  // Notice the line about uses `ChartSeriesType` instead of TSeriesType.\n  // That's probably because the series.type is not propagated from the generic but hardcoded in the config.\n\n  series.forEach((seriesData, seriesIndex) => {\n    const seriesWithDefaultValues = seriesConfig[seriesData.type].getSeriesWithDefaultValues(seriesData, seriesIndex, colors);\n    const id = seriesWithDefaultValues.id;\n    if (seriesGroups[seriesData.type] === undefined) {\n      seriesGroups[seriesData.type] = {\n        series: {},\n        seriesOrder: []\n      };\n    }\n    if (seriesGroups[seriesData.type]?.series[id] !== undefined) {\n      throw new Error(`MUI X Charts: series' id \"${id}\" is not unique.`);\n    }\n    seriesGroups[seriesData.type].series[id] = seriesWithDefaultValues;\n    seriesGroups[seriesData.type].seriesOrder.push(id);\n  });\n  const processedSeries = {};\n  // Apply formatter on a type group\n  Object.keys(seriesConfig).forEach(type => {\n    const group = seriesGroups[type];\n    if (group !== undefined) {\n      processedSeries[type] = seriesConfig[type]?.seriesProcessor?.(group, dataset) ?? seriesGroups[type];\n    }\n  });\n  return processedSeries;\n};\nexports.preprocessSeries = preprocessSeries;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,gBAAgB,GAAG,KAAK,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,gBAAgB,GAAGA,CAAC;EACxBC,MAAM;EACNC,MAAM;EACNC,YAAY;EACZC;AACF,CAAC,KAAK;EACJ;EACA,MAAMC,YAAY,GAAG,CAAC,CAAC;EACvB;EACA;;EAEAJ,MAAM,CAACK,OAAO,CAAC,CAACC,UAAU,EAAEC,WAAW,KAAK;IAC1C,MAAMC,uBAAuB,GAAGN,YAAY,CAACI,UAAU,CAACG,IAAI,CAAC,CAACC,0BAA0B,CAACJ,UAAU,EAAEC,WAAW,EAAEN,MAAM,CAAC;IACzH,MAAMU,EAAE,GAAGH,uBAAuB,CAACG,EAAE;IACrC,IAAIP,YAAY,CAACE,UAAU,CAACG,IAAI,CAAC,KAAKG,SAAS,EAAE;MAC/CR,YAAY,CAACE,UAAU,CAACG,IAAI,CAAC,GAAG;QAC9BT,MAAM,EAAE,CAAC,CAAC;QACVa,WAAW,EAAE;MACf,CAAC;IACH;IACA,IAAIT,YAAY,CAACE,UAAU,CAACG,IAAI,CAAC,EAAET,MAAM,CAACW,EAAE,CAAC,KAAKC,SAAS,EAAE;MAC3D,MAAM,IAAIE,KAAK,CAAC,6BAA6BH,EAAE,kBAAkB,CAAC;IACpE;IACAP,YAAY,CAACE,UAAU,CAACG,IAAI,CAAC,CAACT,MAAM,CAACW,EAAE,CAAC,GAAGH,uBAAuB;IAClEJ,YAAY,CAACE,UAAU,CAACG,IAAI,CAAC,CAACI,WAAW,CAACE,IAAI,CAACJ,EAAE,CAAC;EACpD,CAAC,CAAC;EACF,MAAMK,eAAe,GAAG,CAAC,CAAC;EAC1B;EACArB,MAAM,CAACsB,IAAI,CAACf,YAAY,CAAC,CAACG,OAAO,CAACI,IAAI,IAAI;IACxC,MAAMS,KAAK,GAAGd,YAAY,CAACK,IAAI,CAAC;IAChC,IAAIS,KAAK,KAAKN,SAAS,EAAE;MACvBI,eAAe,CAACP,IAAI,CAAC,GAAGP,YAAY,CAACO,IAAI,CAAC,EAAEU,eAAe,GAAGD,KAAK,EAAEf,OAAO,CAAC,IAAIC,YAAY,CAACK,IAAI,CAAC;IACrG;EACF,CAAC,CAAC;EACF,OAAOO,eAAe;AACxB,CAAC;AACDnB,OAAO,CAACE,gBAAgB,GAAGA,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}